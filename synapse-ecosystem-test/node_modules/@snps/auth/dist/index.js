import { scrypt, randomBytes, timingSafeEqual, createHmac, createHash } from 'crypto';
export class Auth {
    authorizationCodes = new Map();
    accessTokens = new Map();
    csrfTokens = new Map();
    jwtSecret = randomBytes(32).toString('hex');
    hash(password) {
        return new Promise((resolve, reject) => {
            const salt = randomBytes(16).toString('hex');
            scrypt(password, salt, 64, (err, derivedKey) => {
                if (err) {
                    reject(err);
                }
                resolve(`${salt}:${derivedKey.toString('hex')}`);
            });
        });
    }
    compare(password, hash) {
        return new Promise((resolve, reject) => {
            const [salt, key] = hash.split(':');
            if (!salt || !key) {
                return resolve(false);
            }
            const keyBuffer = Buffer.from(key, 'hex');
            scrypt(password, salt, 64, (err, derivedKey) => {
                if (err) {
                    reject(err);
                }
                if (keyBuffer.length !== derivedKey.length) {
                    return resolve(false);
                }
                resolve(timingSafeEqual(keyBuffer, derivedKey));
            });
        });
    }
    issueAuthorizationCode(clientId, redirectUri, scope, state) {
        return new Promise((resolve) => {
            const code = randomBytes(32).toString('hex');
            const expiresAt = Date.now() + 5 * 60 * 1000; // 5 minutes
            this.authorizationCodes.set(code, { clientId, redirectUri, scope, state, code, expiresAt });
            resolve(code);
        });
    }
    exchangeAuthorizationCodeForToken(clientId, redirectUri, code) {
        return new Promise((resolve) => {
            const authorizationCode = this.authorizationCodes.get(code);
            if (!authorizationCode || authorizationCode.clientId !== clientId || authorizationCode.redirectUri !== redirectUri || authorizationCode.expiresAt < Date.now()) {
                return resolve(null);
            }
            this.authorizationCodes.delete(code); // Authorization codes are single-use
            const accessToken = randomBytes(32).toString('hex');
            const expiresAt = Date.now() + 60 * 60 * 1000; // 1 hour
            this.accessTokens.set(accessToken, { token: accessToken, clientId, scope: authorizationCode.scope, expiresAt });
            resolve(accessToken);
        });
    }
    validateAccessToken(token) {
        return new Promise((resolve) => {
            const accessToken = this.accessTokens.get(token);
            if (!accessToken || accessToken.expiresAt < Date.now()) {
                return resolve(false);
            }
            resolve(true);
        });
    }
    async generateCSRFToken() {
        const token = randomBytes(32).toString('hex');
        this.csrfTokens.set(token, Date.now() + 60 * 60 * 1000); // 1 hour expiry
        return token;
    }
    async validateCSRFToken(token) {
        const expiry = this.csrfTokens.get(token);
        if (!expiry || expiry < Date.now()) {
            this.csrfTokens.delete(token);
            return false;
        }
        return true;
    }
    async generateJWT(payload) {
        const header = {
            alg: 'HS256',
            typ: 'JWT'
        };
        const now = Math.floor(Date.now() / 1000);
        const jwtPayload = {
            ...payload,
            iat: now,
            exp: now + 3600 // 1 hour
        };
        const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');
        const encodedPayload = Buffer.from(JSON.stringify(jwtPayload)).toString('base64url');
        const signature = createHmac('sha256', this.jwtSecret)
            .update(`${encodedHeader}.${encodedPayload}`)
            .digest('base64url');
        return `${encodedHeader}.${encodedPayload}.${signature}`;
    }
    async verifyJWT(token) {
        try {
            const parts = token.split('.');
            if (parts.length !== 3)
                return null;
            const [header, payload, signature] = parts;
            const expectedSignature = createHmac('sha256', this.jwtSecret)
                .update(`${header}.${payload}`)
                .digest('base64url');
            if (signature !== expectedSignature)
                return null;
            const decodedPayload = JSON.parse(Buffer.from(payload || '', 'base64url').toString());
            if (decodedPayload.exp < Math.floor(Date.now() / 1000)) {
                return null; // Token expired
            }
            return decodedPayload;
        }
        catch {
            return null;
        }
    }
}
export class SecurityManager {
    rateLimitMap = new Map();
    sanitizeInput(input) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#x2F;'
        };
        return input.replace(/[&<>"'/]/g, (char) => map[char] || char);
    }
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
    isStrongPassword(password) {
        // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special character
        const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
        return strongPasswordRegex.test(password);
    }
    detectSQLInjection(input) {
        const sqlPatterns = [
            /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/i,
            /(\b(OR|AND)\s+\d+\s*=\s*\d+)/i,
            /(\b(OR|AND)\s+['"]\s*=\s*['"])/i,
            /(\b(OR|AND)\s+['"]\s*LIKE\s*['"])/i,
            /(;\s*(DROP|DELETE|INSERT|UPDATE|CREATE|ALTER))/i,
            /(\bUNION\s+SELECT\b)/i,
            /(\bEXEC\s*\()/i,
            /(\bSCRIPT\b)/i
        ];
        return sqlPatterns.some(pattern => pattern.test(input));
    }
    detectXSS(input) {
        const xssPatterns = [
            /<script[^>]*>.*?<\/script>/gi,
            /<iframe[^>]*>.*?<\/iframe>/gi,
            /<object[^>]*>.*?<\/object>/gi,
            /<embed[^>]*>.*?<\/embed>/gi,
            /<link[^>]*>.*?<\/link>/gi,
            /<meta[^>]*>.*?<\/meta>/gi,
            /<style[^>]*>.*?<\/style>/gi,
            /javascript:/gi,
            /vbscript:/gi,
            /onload\s*=/gi,
            /onerror\s*=/gi,
            /onclick\s*=/gi,
            /onmouseover\s*=/gi
        ];
        return xssPatterns.some(pattern => pattern.test(input));
    }
    async checkRateLimit(clientId, maxRequests, windowMs) {
        const now = Date.now();
        const key = `${clientId}:${Math.floor(now / windowMs)}`;
        const current = this.rateLimitMap.get(key);
        if (!current) {
            this.rateLimitMap.set(key, { count: 1, resetTime: now + windowMs });
            return true;
        }
        if (current.count >= maxRequests) {
            return false;
        }
        current.count++;
        return true;
    }
    generateSecureToken(length = 32) {
        return randomBytes(length).toString('hex');
    }
    hashWithSalt(input, salt) {
        const actualSalt = salt || randomBytes(16).toString('hex');
        const hash = createHash('sha256').update(input + actualSalt).digest('hex');
        return `${actualSalt}:${hash}`;
    }
    verifyHash(input, hash) {
        const [salt, hashValue] = hash.split(':');
        if (!salt || !hashValue)
            return false;
        const computedHash = createHash('sha256').update(input + salt).digest('hex');
        return computedHash === hashValue;
    }
}
export class SessionManager {
    sessions = new Map();
    async createSession(userId, data = {}, expiresInMs = 24 * 60 * 60 * 1000) {
        const sessionId = randomBytes(32).toString('hex');
        const session = {
            sessionId,
            userId,
            data,
            expiresAt: Date.now() + expiresInMs
        };
        this.sessions.set(sessionId, session);
        return sessionId;
    }
    async validateSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session || session.expiresAt < Date.now()) {
            if (session) {
                this.sessions.delete(sessionId);
            }
            return false;
        }
        return true;
    }
    async getSessionData(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session || session.expiresAt < Date.now()) {
            if (session) {
                this.sessions.delete(sessionId);
            }
            return null;
        }
        return session.data;
    }
    async updateSessionData(sessionId, data) {
        const session = this.sessions.get(sessionId);
        if (!session || session.expiresAt < Date.now()) {
            if (session) {
                this.sessions.delete(sessionId);
            }
            return false;
        }
        session.data = { ...session.data, ...data };
        return true;
    }
    async destroySession(sessionId) {
        return this.sessions.delete(sessionId);
    }
    async destroyAllUserSessions(userId) {
        let destroyed = 0;
        for (const [sessionId, session] of this.sessions) {
            if (session.userId === userId) {
                this.sessions.delete(sessionId);
                destroyed++;
            }
        }
        return destroyed;
    }
    async cleanupExpiredSessions() {
        const now = Date.now();
        let cleaned = 0;
        for (const [sessionId, session] of this.sessions) {
            if (session.expiresAt < now) {
                this.sessions.delete(sessionId);
                cleaned++;
            }
        }
        return cleaned;
    }
}
//# sourceMappingURL=index.js.map