import { test, describe } from 'node:test';
import assert from 'node:assert';
import { Auth, SecurityManager, SessionManager } from '../index.js';
describe('Auth', () => {
    const auth = new Auth();
    test('should hash and compare a password', async () => {
        const password = 'password123';
        const hash = await auth.hash(password);
        const result = await auth.compare(password, hash);
        assert.strictEqual(result, true);
    });
    test('should return false for a wrong password', async () => {
        const password = 'password123';
        const wrongPassword = 'wrongpassword';
        const hash = await auth.hash(password);
        const result = await auth.compare(wrongPassword, hash);
        assert.strictEqual(result, false);
    });
    test('should issue an authorization code', async () => {
        const clientId = 'test-client';
        const redirectUri = 'http://localhost:3000/callback';
        const scope = 'read write';
        const state = '12345';
        const authorizationCode = await auth.issueAuthorizationCode(clientId, redirectUri, scope, state);
        assert.ok(authorizationCode);
        assert.strictEqual(typeof authorizationCode, 'string');
    });
    test('should exchange an authorization code for an access token', async () => {
        const clientId = 'test-client';
        const redirectUri = 'http://localhost:3000/callback';
        const scope = 'read write';
        const state = '12345';
        const authorizationCode = await auth.issueAuthorizationCode(clientId, redirectUri, scope, state);
        const accessToken = await auth.exchangeAuthorizationCodeForToken(clientId, redirectUri, authorizationCode);
        assert.ok(accessToken);
        assert.strictEqual(typeof accessToken, 'string');
    });
    test('should validate an access token', async () => {
        const clientId = 'test-client';
        const redirectUri = 'http://localhost:3000/callback';
        const scope = 'read write';
        const state = '12345';
        const authorizationCode = await auth.issueAuthorizationCode(clientId, redirectUri, scope, state);
        const accessToken = await auth.exchangeAuthorizationCodeForToken(clientId, redirectUri, authorizationCode);
        assert.ok(accessToken);
        const isValid = await auth.validateAccessToken(accessToken);
        assert.strictEqual(isValid, true);
    });
    test('should generate secure CSRF token', async () => {
        const csrfToken = await auth.generateCSRFToken();
        assert.strictEqual(typeof csrfToken, 'string');
        assert.strictEqual(csrfToken.length, 64);
    });
    test('should validate CSRF token', async () => {
        const csrfToken = await auth.generateCSRFToken();
        const isValid = await auth.validateCSRFToken(csrfToken);
        assert.strictEqual(isValid, true);
    });
    test('should reject invalid CSRF token', async () => {
        const isValid = await auth.validateCSRFToken('invalid-token');
        assert.strictEqual(isValid, false);
    });
    test('should generate JWT token', async () => {
        const payload = { userId: '123', role: 'admin' };
        const token = await auth.generateJWT(payload);
        assert.strictEqual(typeof token, 'string');
        assert(token.includes('.'));
    });
    test('should verify JWT token', async () => {
        const payload = { userId: '123', role: 'admin' };
        const token = await auth.generateJWT(payload);
        const decoded = await auth.verifyJWT(token);
        assert.strictEqual(decoded?.userId, payload.userId);
        assert.strictEqual(decoded?.role, payload.role);
        assert(decoded?.iat);
        assert(decoded?.exp);
    });
    test('should reject invalid JWT token', async () => {
        const decoded = await auth.verifyJWT('invalid-token');
        assert.strictEqual(decoded, null);
    });
});
describe('SecurityManager', () => {
    const security = new SecurityManager();
    test('should sanitize input', () => {
        const input = '<script>alert("xss")</script>';
        const sanitized = security.sanitizeInput(input);
        assert(sanitized.includes('&lt;script&gt;'));
        assert(sanitized.includes('&quot;xss&quot;'));
        assert(sanitized.includes('&lt;&#x2F;script&gt;'));
    });
    test('should validate email format', () => {
        assert.strictEqual(security.isValidEmail('test@example.com'), true);
        assert.strictEqual(security.isValidEmail('invalid-email'), false);
    });
    test('should validate password strength', () => {
        assert.strictEqual(security.isStrongPassword('Password123!'), true);
        assert.strictEqual(security.isStrongPassword('weak'), false);
    });
    test('should detect SQL injection attempts', () => {
        assert.strictEqual(security.detectSQLInjection("'; DROP TABLE users; --"), true);
        assert.strictEqual(security.detectSQLInjection('normal query'), false);
    });
    test('should detect XSS attempts', () => {
        assert.strictEqual(security.detectXSS('<script>alert("xss")</script>'), true);
        assert.strictEqual(security.detectXSS('normal text'), false);
    });
    test('should rate limit requests', async () => {
        const clientId = 'test-client';
        // First request should be allowed
        const allowed1 = await security.checkRateLimit(clientId, 5, 60000);
        assert.strictEqual(allowed1, true);
        // Make 5 more requests to exceed limit
        for (let i = 0; i < 5; i++) {
            await security.checkRateLimit(clientId, 5, 60000);
        }
        // Next request should be blocked
        const blocked = await security.checkRateLimit(clientId, 5, 60000);
        assert.strictEqual(blocked, false);
    });
});
describe('SessionManager', () => {
    const sessionManager = new SessionManager();
    test('should create session', async () => {
        const sessionId = await sessionManager.createSession('user123', { role: 'admin' });
        assert.strictEqual(typeof sessionId, 'string');
        assert.strictEqual(sessionId.length, 64);
    });
    test('should validate session', async () => {
        const sessionId = await sessionManager.createSession('user123', { role: 'admin' });
        const isValid = await sessionManager.validateSession(sessionId);
        assert.strictEqual(isValid, true);
    });
    test('should get session data', async () => {
        const sessionId = await sessionManager.createSession('user123', { role: 'admin' });
        const data = await sessionManager.getSessionData(sessionId);
        assert.strictEqual(data?.role, 'admin');
        assert(data !== null);
    });
    test('should destroy session', async () => {
        const sessionId = await sessionManager.createSession('user123', { role: 'admin' });
        await sessionManager.destroySession(sessionId);
        const isValid = await sessionManager.validateSession(sessionId);
        assert.strictEqual(isValid, false);
    });
    test('should handle expired sessions', async () => {
        const sessionId = await sessionManager.createSession('user123', { role: 'admin' }, 100); // 100ms expiry
        // Wait for session to expire
        await new Promise(resolve => setTimeout(resolve, 150));
        const isValid = await sessionManager.validateSession(sessionId);
        assert.strictEqual(isValid, false);
    });
});
//# sourceMappingURL=auth.test.js.map