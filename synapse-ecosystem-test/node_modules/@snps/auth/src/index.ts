import { scrypt, randomBytes, timingSafeEqual, createHmac, createHash } from 'crypto';

interface AuthorizationCode {
  clientId: string;
  redirectUri: string;
  scope: string;
  state: string;
  code: string;
  expiresAt: number;
}

interface AccessToken {
  token: string;
  clientId: string;
  scope: string;
  expiresAt: number;
}

interface Session {
  sessionId: string;
  userId: string;
  data: Record<string, any>;
  expiresAt: number;
}

export class Auth {
  private authorizationCodes: Map<string, AuthorizationCode> = new Map();
  private accessTokens: Map<string, AccessToken> = new Map();
  private csrfTokens: Map<string, number> = new Map();
  private jwtSecret: string = randomBytes(32).toString('hex');

  public hash(password: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const salt = randomBytes(16).toString('hex');
      scrypt(password, salt, 64, (err, derivedKey) => {
        if (err) {
          reject(err);
        }
        resolve(`${salt}:${derivedKey.toString('hex')}`);
      });
    });
  }

  public compare(password: string, hash: string): Promise<boolean> {
    return new Promise((resolve, reject) => {
      const [salt, key] = hash.split(':');
      if (!salt || !key) {
        return resolve(false);
      }
      const keyBuffer = Buffer.from(key, 'hex');
      scrypt(password, salt, 64, (err, derivedKey) => {
        if (err) {
          reject(err);
        }
        if (keyBuffer.length !== derivedKey.length) {
          return resolve(false);
        }
        resolve(timingSafeEqual(keyBuffer, derivedKey));
      });
    });
  }

  public issueAuthorizationCode(clientId: string, redirectUri: string, scope: string, state: string): Promise<string> {
    return new Promise((resolve) => {
      const code = randomBytes(32).toString('hex');
      const expiresAt = Date.now() + 5 * 60 * 1000; // 5 minutes
      this.authorizationCodes.set(code, { clientId, redirectUri, scope, state, code, expiresAt });
      resolve(code);
    });
  }

  public exchangeAuthorizationCodeForToken(clientId: string, redirectUri: string, code: string): Promise<string | null> {
    return new Promise((resolve) => {
      const authorizationCode = this.authorizationCodes.get(code);

      if (!authorizationCode || authorizationCode.clientId !== clientId || authorizationCode.redirectUri !== redirectUri || authorizationCode.expiresAt < Date.now()) {
        return resolve(null);
      }

      this.authorizationCodes.delete(code); // Authorization codes are single-use

      const accessToken = randomBytes(32).toString('hex');
      const expiresAt = Date.now() + 60 * 60 * 1000; // 1 hour
      this.accessTokens.set(accessToken, { token: accessToken, clientId, scope: authorizationCode.scope, expiresAt });
      resolve(accessToken);
    });
  }

  public validateAccessToken(token: string): Promise<boolean> {
    return new Promise((resolve) => {
      const accessToken = this.accessTokens.get(token);
      if (!accessToken || accessToken.expiresAt < Date.now()) {
        return resolve(false);
      }
      resolve(true);
    });
  }

  public async generateCSRFToken(): Promise<string> {
    const token = randomBytes(32).toString('hex');
    this.csrfTokens.set(token, Date.now() + 60 * 60 * 1000); // 1 hour expiry
    return token;
  }

  public async validateCSRFToken(token: string): Promise<boolean> {
    const expiry = this.csrfTokens.get(token);
    if (!expiry || expiry < Date.now()) {
      this.csrfTokens.delete(token);
      return false;
    }
    return true;
  }

  public async generateJWT(payload: Record<string, any>): Promise<string> {
    const header = {
      alg: 'HS256',
      typ: 'JWT'
    };

    const now = Math.floor(Date.now() / 1000);
    const jwtPayload = {
      ...payload,
      iat: now,
      exp: now + 3600 // 1 hour
    };

    const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');
    const encodedPayload = Buffer.from(JSON.stringify(jwtPayload)).toString('base64url');
    
    const signature = createHmac('sha256', this.jwtSecret)
      .update(`${encodedHeader}.${encodedPayload}`)
      .digest('base64url');

    return `${encodedHeader}.${encodedPayload}.${signature}`;
  }

  public async verifyJWT(token: string): Promise<Record<string, any> | null> {
    try {
      const parts = token.split('.');
      if (parts.length !== 3) return null;

      const [header, payload, signature] = parts;
      
      const expectedSignature = createHmac('sha256', this.jwtSecret)
        .update(`${header}.${payload}`)
        .digest('base64url');

      if (signature !== expectedSignature) return null;

      const decodedPayload = JSON.parse(Buffer.from(payload || '', 'base64url').toString());
      
      if (decodedPayload.exp < Math.floor(Date.now() / 1000)) {
        return null; // Token expired
      }

      return decodedPayload;
    } catch {
      return null;
    }
  }
}

export class SecurityManager {
  private rateLimitMap: Map<string, { count: number; resetTime: number }> = new Map();

  public sanitizeInput(input: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '/': '&#x2F;'
    };
    
    return input.replace(/[&<>"'/]/g, (char) => map[char] || char);
  }

  public isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  public isStrongPassword(password: string): boolean {
    // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special character
    const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return strongPasswordRegex.test(password);
  }

  public detectSQLInjection(input: string): boolean {
    const sqlPatterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/i,
      /(\b(OR|AND)\s+\d+\s*=\s*\d+)/i,
      /(\b(OR|AND)\s+['"]\s*=\s*['"])/i,
      /(\b(OR|AND)\s+['"]\s*LIKE\s*['"])/i,
      /(;\s*(DROP|DELETE|INSERT|UPDATE|CREATE|ALTER))/i,
      /(\bUNION\s+SELECT\b)/i,
      /(\bEXEC\s*\()/i,
      /(\bSCRIPT\b)/i
    ];

    return sqlPatterns.some(pattern => pattern.test(input));
  }

  public detectXSS(input: string): boolean {
    const xssPatterns = [
      /<script[^>]*>.*?<\/script>/gi,
      /<iframe[^>]*>.*?<\/iframe>/gi,
      /<object[^>]*>.*?<\/object>/gi,
      /<embed[^>]*>.*?<\/embed>/gi,
      /<link[^>]*>.*?<\/link>/gi,
      /<meta[^>]*>.*?<\/meta>/gi,
      /<style[^>]*>.*?<\/style>/gi,
      /javascript:/gi,
      /vbscript:/gi,
      /onload\s*=/gi,
      /onerror\s*=/gi,
      /onclick\s*=/gi,
      /onmouseover\s*=/gi
    ];

    return xssPatterns.some(pattern => pattern.test(input));
  }

  public async checkRateLimit(clientId: string, maxRequests: number, windowMs: number): Promise<boolean> {
    const now = Date.now();
    const key = `${clientId}:${Math.floor(now / windowMs)}`;
    
    const current = this.rateLimitMap.get(key);
    
    if (!current) {
      this.rateLimitMap.set(key, { count: 1, resetTime: now + windowMs });
      return true;
    }
    
    if (current.count >= maxRequests) {
      return false;
    }
    
    current.count++;
    return true;
  }

  public generateSecureToken(length: number = 32): string {
    return randomBytes(length).toString('hex');
  }

  public hashWithSalt(input: string, salt?: string): string {
    const actualSalt = salt || randomBytes(16).toString('hex');
    const hash = createHash('sha256').update(input + actualSalt).digest('hex');
    return `${actualSalt}:${hash}`;
  }

  public verifyHash(input: string, hash: string): boolean {
    const [salt, hashValue] = hash.split(':');
    if (!salt || !hashValue) return false;
    
    const computedHash = createHash('sha256').update(input + salt).digest('hex');
    return computedHash === hashValue;
  }
}

export class SessionManager {
  private sessions: Map<string, Session> = new Map();

  public async createSession(userId: string, data: Record<string, any> = {}, expiresInMs: number = 24 * 60 * 60 * 1000): Promise<string> {
    const sessionId = randomBytes(32).toString('hex');
    const session: Session = {
      sessionId,
      userId,
      data,
      expiresAt: Date.now() + expiresInMs
    };
    
    this.sessions.set(sessionId, session);
    return sessionId;
  }

  public async validateSession(sessionId: string): Promise<boolean> {
    const session = this.sessions.get(sessionId);
    if (!session || session.expiresAt < Date.now()) {
      if (session) {
        this.sessions.delete(sessionId);
      }
      return false;
    }
    return true;
  }

  public async getSessionData(sessionId: string): Promise<Record<string, any> | null> {
    const session = this.sessions.get(sessionId);
    if (!session || session.expiresAt < Date.now()) {
      if (session) {
        this.sessions.delete(sessionId);
      }
      return null;
    }
    return session.data;
  }

  public async updateSessionData(sessionId: string, data: Record<string, any>): Promise<boolean> {
    const session = this.sessions.get(sessionId);
    if (!session || session.expiresAt < Date.now()) {
      if (session) {
        this.sessions.delete(sessionId);
      }
      return false;
    }
    
    session.data = { ...session.data, ...data };
    return true;
  }

  public async destroySession(sessionId: string): Promise<boolean> {
    return this.sessions.delete(sessionId);
  }

  public async destroyAllUserSessions(userId: string): Promise<number> {
    let destroyed = 0;
    for (const [sessionId, session] of this.sessions) {
      if (session.userId === userId) {
        this.sessions.delete(sessionId);
        destroyed++;
      }
    }
    return destroyed;
  }

  public async cleanupExpiredSessions(): Promise<number> {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [sessionId, session] of this.sessions) {
      if (session.expiresAt < now) {
        this.sessions.delete(sessionId);
        cleaned++;
      }
    }
    
    return cleaned;
  }
}
