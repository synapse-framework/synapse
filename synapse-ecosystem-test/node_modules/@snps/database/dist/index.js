import { randomUUID } from 'node:crypto';
export class QueryBuilder {
    conditions = {};
    where(field, value) {
        this.conditions[field] = value;
        return this;
    }
    orWhere(field, value) {
        if (!this.conditions.$or) {
            this.conditions.$or = [];
        }
        this.conditions.$or.push({ [field]: value });
        return this;
    }
    andWhere(field, value) {
        if (!this.conditions.$and) {
            this.conditions.$and = [];
        }
        this.conditions.$and.push({ [field]: value });
        return this;
    }
    build() {
        return { ...this.conditions };
    }
}
export class Model {
    id;
    static database;
    static setDatabase(database) {
        this.database = database;
    }
    async save() {
        const database = this.constructor.database;
        if (!database) {
            throw new Error('Database not set. Call Model.setDatabase() first.');
        }
        if (!this.id) {
            this.id = randomUUID();
        }
        const data = this.toJSON();
        await database.set(this.constructor.tableName, this.id, data);
    }
    async delete() {
        const database = this.constructor.database;
        if (!database || !this.id) {
            throw new Error('Database not set or model not saved.');
        }
        await database.delete(this.constructor.tableName, this.id);
    }
    static async findById(id) {
        const database = this.database;
        if (!database) {
            throw new Error('Database not set. Call Model.setDatabase() first.');
        }
        const data = await database.get(this.tableName, id);
        if (!data)
            return null;
        const instance = new this();
        instance.id = id;
        Object.assign(instance, data);
        return instance;
    }
    static async find(query = {}) {
        const database = this.database;
        if (!database) {
            throw new Error('Database not set. Call Model.setDatabase() first.');
        }
        const results = await database.find(this.tableName, query);
        return results.map((data) => {
            const instance = new this();
            instance.id = data.id;
            Object.assign(instance, data);
            return instance;
        });
    }
    toJSON() {
        const json = {};
        for (const key in this) {
            if (key !== 'id' && typeof this[key] !== 'function') {
                json[key] = this[key];
            }
        }
        return json;
    }
}
export class Database {
    data = new Map();
    connected = false;
    connect() {
        return new Promise((resolve) => {
            console.log('Database connected');
            this.connected = true;
            resolve();
        });
    }
    disconnect() {
        return new Promise((resolve) => {
            console.log('Database disconnected');
            this.connected = false;
            resolve();
        });
    }
    async set(collectionName, key, value) {
        return new Promise((resolve) => {
            if (!this.data.has(collectionName)) {
                this.data.set(collectionName, new Map());
            }
            this.data.get(collectionName)?.set(key, value);
            resolve();
        });
    }
    async get(collectionName, key) {
        return new Promise((resolve) => {
            resolve(this.data.get(collectionName)?.get(key));
        });
    }
    async delete(collectionName, key) {
        return new Promise((resolve) => {
            this.data.get(collectionName)?.delete(key);
            resolve();
        });
    }
    async clear(collectionName) {
        return new Promise((resolve) => {
            if (collectionName) {
                this.data.delete(collectionName);
            }
            else {
                this.data.clear();
            }
            resolve();
        });
    }
    async find(collectionName, query = {}) {
        return new Promise((resolve) => {
            const collection = this.data.get(collectionName);
            if (!collection) {
                resolve([]);
                return;
            }
            const results = [];
            for (const [key, value] of collection) {
                if (this.matchesQuery(value, query)) {
                    results.push({ id: key, ...value });
                }
            }
            resolve(results);
        });
    }
    async update(collectionName, key, updates) {
        return new Promise((resolve) => {
            const collection = this.data.get(collectionName);
            if (!collection) {
                resolve();
                return;
            }
            const existing = collection.get(key);
            if (existing) {
                const updated = { ...existing, ...updates };
                collection.set(key, updated);
            }
            resolve();
        });
    }
    async count(collectionName, query = {}) {
        return new Promise((resolve) => {
            const collection = this.data.get(collectionName);
            if (!collection) {
                resolve(0);
                return;
            }
            let count = 0;
            for (const [key, value] of collection) {
                if (this.matchesQuery(value, query)) {
                    count++;
                }
            }
            resolve(count);
        });
    }
    matchesQuery(document, query) {
        for (const [field, condition] of Object.entries(query)) {
            if (field === '$or') {
                if (!Array.isArray(condition))
                    return false;
                const orMatches = condition.some(orCondition => this.matchesQuery(document, orCondition));
                if (!orMatches)
                    return false;
                continue;
            }
            if (field === '$and') {
                if (!Array.isArray(condition))
                    return false;
                const andMatches = condition.every(andCondition => this.matchesQuery(document, andCondition));
                if (!andMatches)
                    return false;
                continue;
            }
            const value = this.getNestedValue(document, field);
            if (typeof condition === 'object' && condition !== null && !Array.isArray(condition)) {
                // Handle operators
                const operators = condition;
                if (operators.$eq !== undefined && value !== operators.$eq)
                    return false;
                if (operators.$ne !== undefined && value === operators.$ne)
                    return false;
                if (operators.$gt !== undefined && value <= operators.$gt)
                    return false;
                if (operators.$gte !== undefined && value < operators.$gte)
                    return false;
                if (operators.$lt !== undefined && value >= operators.$lt)
                    return false;
                if (operators.$lte !== undefined && value > operators.$lte)
                    return false;
                if (operators.$in !== undefined && !operators.$in.includes(value))
                    return false;
                if (operators.$nin !== undefined && operators.$nin.includes(value))
                    return false;
                if (operators.$exists !== undefined) {
                    const exists = value !== undefined;
                    if (exists !== operators.$exists)
                        return false;
                }
                if (operators.$regex !== undefined) {
                    const regex = new RegExp(operators.$regex);
                    if (!regex.test(String(value)))
                        return false;
                }
            }
            else {
                // Direct comparison
                if (value !== condition)
                    return false;
            }
        }
        return true;
    }
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => {
            return current && current[key] !== undefined ? current[key] : undefined;
        }, obj);
    }
}
//# sourceMappingURL=index.js.map