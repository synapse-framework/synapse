import { randomUUID } from 'node:crypto';

export interface QueryOperators {
  $eq?: any;
  $ne?: any;
  $gt?: any;
  $gte?: any;
  $lt?: any;
  $lte?: any;
  $in?: any[];
  $nin?: any[];
  $exists?: boolean;
  $regex?: string;
  $or?: Record<string, any>[];
  $and?: Record<string, any>[];
}

export type Query = Record<string, any | QueryOperators>;

export class QueryBuilder {
  private conditions: Record<string, any> = {};

  public where(field: string, value: any): QueryBuilder {
    this.conditions[field] = value;
    return this;
  }

  public orWhere(field: string, value: any): QueryBuilder {
    if (!this.conditions.$or) {
      this.conditions.$or = [];
    }
    this.conditions.$or.push({ [field]: value });
    return this;
  }

  public andWhere(field: string, value: any): QueryBuilder {
    if (!this.conditions.$and) {
      this.conditions.$and = [];
    }
    this.conditions.$and.push({ [field]: value });
    return this;
  }

  public build(): Query {
    return { ...this.conditions };
  }
}

export abstract class Model {
  public id?: string;
  protected static database?: Database;

  public static setDatabase(database: Database): void {
    (this as any).database = database;
  }

  public async save(): Promise<void> {
    const database = (this.constructor as any).database;
    if (!database) {
      throw new Error('Database not set. Call Model.setDatabase() first.');
    }

    if (!this.id) {
      this.id = randomUUID();
    }

    const data = this.toJSON();
    await database.set(
      (this.constructor as any).tableName,
      this.id,
      data
    );
  }

  public async delete(): Promise<void> {
    const database = (this.constructor as any).database;
    if (!database || !this.id) {
      throw new Error('Database not set or model not saved.');
    }

    await database.delete(
      (this.constructor as any).tableName,
      this.id
    );
  }

  public static async findById(id: string): Promise<Model | null> {
    const database = (this as any).database;
    if (!database) {
      throw new Error('Database not set. Call Model.setDatabase() first.');
    }

    const data = await database.get((this as any).tableName, id);
    if (!data) return null;

    const instance = new (this as any)();
    instance.id = id;
    Object.assign(instance, data);
    return instance;
  }

  public static async find(query: Query = {}): Promise<Model[]> {
    const database = (this as any).database;
    if (!database) {
      throw new Error('Database not set. Call Model.setDatabase() first.');
    }

    const results = await database.find((this as any).tableName, query);
    return results.map((data: any) => {
      const instance = new (this as any)();
      instance.id = data.id;
      Object.assign(instance, data);
      return instance;
    });
  }

  protected toJSON(): Record<string, any> {
    const json: Record<string, any> = {};
    for (const key in this) {
      if (key !== 'id' && typeof (this as any)[key] !== 'function') {
        json[key] = (this as any)[key];
      }
    }
    return json;
  }
}

export class Database {
  private data: Map<string, Map<string, any>> = new Map();
  private connected: boolean = false;

  public connect(): Promise<void> {
    return new Promise((resolve) => {
      console.log('Database connected');
      this.connected = true;
      resolve();
    });
  }

  public disconnect(): Promise<void> {
    return new Promise((resolve) => {
      console.log('Database disconnected');
      this.connected = false;
      resolve();
    });
  }

  public async set(collectionName: string, key: string, value: any): Promise<void> {
    return new Promise((resolve) => {
      if (!this.data.has(collectionName)) {
        this.data.set(collectionName, new Map<string, any>());
      }
      this.data.get(collectionName)?.set(key, value);
      resolve();
    });
  }

  public async get(collectionName: string, key: string): Promise<any> {
    return new Promise((resolve) => {
      resolve(this.data.get(collectionName)?.get(key));
    });
  }

  public async delete(collectionName: string, key: string): Promise<void> {
    return new Promise((resolve) => {
      this.data.get(collectionName)?.delete(key);
      resolve();
    });
  }

  public async clear(collectionName?: string): Promise<void> {
    return new Promise((resolve) => {
      if (collectionName) {
        this.data.delete(collectionName);
      } else {
        this.data.clear();
      }
      resolve();
    });
  }

  public async find(collectionName: string, query: Query = {}): Promise<any[]> {
    return new Promise((resolve) => {
      const collection = this.data.get(collectionName);
      if (!collection) {
        resolve([]);
        return;
      }

      const results: any[] = [];
      for (const [key, value] of collection) {
        if (this.matchesQuery(value, query)) {
          results.push({ id: key, ...value });
        }
      }
      resolve(results);
    });
  }

  public async update(collectionName: string, key: string, updates: Record<string, any>): Promise<void> {
    return new Promise((resolve) => {
      const collection = this.data.get(collectionName);
      if (!collection) {
        resolve();
        return;
      }

      const existing = collection.get(key);
      if (existing) {
        const updated = { ...existing, ...updates };
        collection.set(key, updated);
      }
      resolve();
    });
  }

  public async count(collectionName: string, query: Query = {}): Promise<number> {
    return new Promise((resolve) => {
      const collection = this.data.get(collectionName);
      if (!collection) {
        resolve(0);
        return;
      }

      let count = 0;
      for (const [key, value] of collection) {
        if (this.matchesQuery(value, query)) {
          count++;
        }
      }
      resolve(count);
    });
  }

  private matchesQuery(document: any, query: Query): boolean {
    for (const [field, condition] of Object.entries(query)) {
      if (field === '$or') {
        if (!Array.isArray(condition)) return false;
        const orMatches = condition.some(orCondition => 
          this.matchesQuery(document, orCondition)
        );
        if (!orMatches) return false;
        continue;
      }

      if (field === '$and') {
        if (!Array.isArray(condition)) return false;
        const andMatches = condition.every(andCondition => 
          this.matchesQuery(document, andCondition)
        );
        if (!andMatches) return false;
        continue;
      }

      const value = this.getNestedValue(document, field);
      
      if (typeof condition === 'object' && condition !== null && !Array.isArray(condition)) {
        // Handle operators
        const operators = condition as QueryOperators;
        
        if (operators.$eq !== undefined && value !== operators.$eq) return false;
        if (operators.$ne !== undefined && value === operators.$ne) return false;
        if (operators.$gt !== undefined && value <= operators.$gt) return false;
        if (operators.$gte !== undefined && value < operators.$gte) return false;
        if (operators.$lt !== undefined && value >= operators.$lt) return false;
        if (operators.$lte !== undefined && value > operators.$lte) return false;
        if (operators.$in !== undefined && !operators.$in.includes(value)) return false;
        if (operators.$nin !== undefined && operators.$nin.includes(value)) return false;
        if (operators.$exists !== undefined) {
          const exists = value !== undefined;
          if (exists !== operators.$exists) return false;
        }
        if (operators.$regex !== undefined) {
          const regex = new RegExp(operators.$regex);
          if (!regex.test(String(value))) return false;
        }
      } else {
        // Direct comparison
        if (value !== condition) return false;
      }
    }
    return true;
  }

  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }
}
