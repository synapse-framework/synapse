import { EventEmitter } from 'node:events';
import { randomUUID } from 'node:crypto';

export interface EmailOptions {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
  from: string;
  replyTo?: string;
}

export interface EmailMessage {
  id: string;
  to: string | string[];
  cc?: string | string[];
  bcc?: string | string[];
  subject: string;
  text?: string;
  html?: string;
  attachments?: EmailAttachment[];
  headers?: Record<string, string>;
  priority?: 'high' | 'normal' | 'low';
  replyTo?: string;
}

export interface EmailAttachment {
  filename: string;
  content: Buffer | string;
  contentType?: string;
  disposition?: 'attachment' | 'inline';
  cid?: string;
}

export interface EmailTemplate {
  name: string;
  subject: string;
  text: string;
  html: string;
  variables: string[];
}

export interface EmailDeliveryStatus {
  messageId: string;
  status: 'pending' | 'sent' | 'delivered' | 'failed' | 'bounced';
  timestamp: Date;
  error?: string;
  retryCount: number;
  nextRetry?: Date;
}

export interface EmailStats {
  totalSent: number;
  totalDelivered: number;
  totalFailed: number;
  totalBounced: number;
  deliveryRate: number;
  failureRate: number;
}

export class EmailService extends EventEmitter {
  private options: EmailOptions;
  private templates: Map<string, EmailTemplate> = new Map();
  private deliveryStatus: Map<string, EmailDeliveryStatus> = new Map();
  private stats: EmailStats = {
    totalSent: 0,
    totalDelivered: 0,
    totalFailed: 0,
    totalBounced: 0,
    deliveryRate: 0,
    failureRate: 0
  };

  constructor(options: EmailOptions) {
    super();
    this.options = options;
  }

  public async send(message: EmailMessage): Promise<boolean> {
    try {
      const messageId = randomUUID();
      message.id = messageId;

      // Update delivery status
      this.deliveryStatus.set(messageId, {
        messageId,
        status: 'pending',
        timestamp: new Date(),
        retryCount: 0
      });

      // Simulate email sending - in a real implementation, you would use a library like nodemailer
      await this.simulateEmailSending(message);

      // Update status to sent
      this.updateDeliveryStatus(messageId, 'sent');
      this.stats.totalSent++;

      this.emit('email-sent', { messageId, message });
      return true;
    } catch (error) {
      this.updateDeliveryStatus(message.id, 'failed', error instanceof Error ? error.message : 'Unknown error');
      this.stats.totalFailed++;
      this.emit('email-failed', { messageId: message.id, error });
      return false;
    }
  }

  public async sendTemplate(templateName: string, to: string | string[], variables: Record<string, any> = {}): Promise<boolean> {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template ${templateName} not found`);
    }

    const message: EmailMessage = {
      id: randomUUID(),
      to,
      subject: this.renderTemplate(template.subject, variables),
      text: this.renderTemplate(template.text, variables),
      html: this.renderTemplate(template.html, variables)
    };

    return this.send(message);
  }

  public addTemplate(template: EmailTemplate): void {
    this.templates.set(template.name, template);
  }

  public getTemplate(name: string): EmailTemplate | undefined {
    return this.templates.get(name);
  }

  public listTemplates(): EmailTemplate[] {
    return Array.from(this.templates.values());
  }

  public async getDeliveryStatus(messageId: string): Promise<EmailDeliveryStatus | undefined> {
    return this.deliveryStatus.get(messageId);
  }

  public getStats(): EmailStats {
    this.calculateStats();
    return { ...this.stats };
  }

  public async retryFailedEmails(): Promise<number> {
    let retryCount = 0;
    const now = new Date();

    for (const [messageId, status] of this.deliveryStatus) {
      if (status.status === 'failed' && status.retryCount < 3) {
        if (!status.nextRetry || status.nextRetry <= now) {
          // In a real implementation, you would retry sending the email
          status.retryCount++;
          status.nextRetry = new Date(now.getTime() + (status.retryCount * 60000)); // Exponential backoff
          retryCount++;
        }
      }
    }

    return retryCount;
  }

  public async markAsDelivered(messageId: string): Promise<void> {
    this.updateDeliveryStatus(messageId, 'delivered');
    this.stats.totalDelivered++;
  }

  public async markAsBounced(messageId: string, reason?: string): Promise<void> {
    this.updateDeliveryStatus(messageId, 'bounced', reason);
    this.stats.totalBounced++;
  }

  private async simulateEmailSending(message: EmailMessage): Promise<void> {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));

    // Simulate occasional failures
    if (Math.random() < 0.1) { // 10% failure rate
      throw new Error('SMTP server temporarily unavailable');
    }
  }

  private renderTemplate(template: string, variables: Record<string, any>): string {
    let rendered = template;

    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`{{${key}}}`, 'g');
      rendered = rendered.replace(regex, String(value));
    }

    return rendered;
  }

  private updateDeliveryStatus(messageId: string, status: EmailDeliveryStatus['status'], error?: string): void {
    const currentStatus = this.deliveryStatus.get(messageId);
    if (currentStatus) {
      currentStatus.status = status;
      currentStatus.timestamp = new Date();
      if (error) {
        currentStatus.error = error;
      }
    }
  }

  private calculateStats(): void {
    const total = this.stats.totalSent;
    if (total > 0) {
      this.stats.deliveryRate = (this.stats.totalDelivered / total) * 100;
      this.stats.failureRate = (this.stats.totalFailed / total) * 100;
    }
  }
}

export class EmailTemplateBuilder {
  private template: Partial<EmailTemplate> = {};

  public name(name: string): EmailTemplateBuilder {
    this.template.name = name;
    return this;
  }

  public subject(subject: string): EmailTemplateBuilder {
    this.template.subject = subject;
    return this;
  }

  public text(text: string): EmailTemplateBuilder {
    this.template.text = text;
    return this;
  }

  public html(html: string): EmailTemplateBuilder {
    this.template.html = html;
    return this;
  }

  public variables(variables: string[]): EmailTemplateBuilder {
    this.template.variables = variables;
    return this;
  }

  public build(): EmailTemplate {
    if (!this.template.name || !this.template.subject || !this.template.text || !this.template.html) {
      throw new Error('Template name, subject, text, and html are required');
    }

    return {
      name: this.template.name,
      subject: this.template.subject,
      text: this.template.text,
      html: this.template.html,
      variables: this.template.variables || []
    };
  }
}

export class EmailValidator {
  public static validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  public static validateMessage(message: EmailMessage): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!message.to) {
      errors.push('Recipient (to) is required');
    } else if (Array.isArray(message.to)) {
      for (const email of message.to) {
        if (!this.validateEmail(email)) {
          errors.push(`Invalid email address: ${email}`);
        }
      }
    } else if (!this.validateEmail(message.to)) {
      errors.push(`Invalid email address: ${message.to}`);
    }

    if (!message.subject || message.subject.trim().length === 0) {
      errors.push('Subject is required');
    }

    if (!message.text && !message.html) {
      errors.push('Either text or html content is required');
    }

    if (message.cc) {
      const ccEmails = Array.isArray(message.cc) ? message.cc : [message.cc];
      for (const email of ccEmails) {
        if (!this.validateEmail(email)) {
          errors.push(`Invalid CC email address: ${email}`);
        }
      }
    }

    if (message.bcc) {
      const bccEmails = Array.isArray(message.bcc) ? message.bcc : [message.bcc];
      for (const email of bccEmails) {
        if (!this.validateEmail(email)) {
          errors.push(`Invalid BCC email address: ${email}`);
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

export class EmailScheduler {
  private scheduledEmails: Map<string, { message: EmailMessage; sendAt: Date }> = new Map();
  private interval: NodeJS.Timeout | undefined;

  constructor(private emailService: EmailService) {
    this.startScheduler();
  }

  public scheduleEmail(message: EmailMessage, sendAt: Date): string {
    const scheduleId = randomUUID();
    this.scheduledEmails.set(scheduleId, { message, sendAt });
    return scheduleId;
  }

  public cancelScheduledEmail(scheduleId: string): boolean {
    return this.scheduledEmails.delete(scheduleId);
  }

  public getScheduledEmails(): Array<{ id: string; message: EmailMessage; sendAt: Date }> {
    return Array.from(this.scheduledEmails.entries()).map(([id, data]) => ({
      id,
      message: data.message,
      sendAt: data.sendAt
    }));
  }

  private startScheduler(): void {
    this.interval = setInterval(() => {
      this.processScheduledEmails();
    }, 60000); // Check every minute
  }

  private async processScheduledEmails(): Promise<void> {
    const now = new Date();
    const toSend: string[] = [];

    for (const [scheduleId, data] of this.scheduledEmails) {
      if (data.sendAt <= now) {
        toSend.push(scheduleId);
      }
    }

    for (const scheduleId of toSend) {
      const data = this.scheduledEmails.get(scheduleId);
      if (data) {
        await this.emailService.send(data.message);
        this.scheduledEmails.delete(scheduleId);
      }
    }
  }

  public stop(): void {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
}
