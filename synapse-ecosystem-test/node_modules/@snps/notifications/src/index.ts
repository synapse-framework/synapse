import { EventEmitter } from 'node:events';
import { randomUUID } from 'node:crypto';

export interface NotificationChannel {
  name: string;
  type: 'email' | 'sms' | 'push' | 'webhook' | 'slack' | 'discord';
  enabled: boolean;
  config: Record<string, any>;
  priority: number;
}

export interface NotificationTemplate {
  id: string;
  name: string;
  subject?: string;
  message: string;
  channels: string[];
  variables: string[];
  category: string;
  enabled: boolean;
}

export interface Notification {
  id: string;
  templateId: string;
  recipient: string;
  channels: string[];
  data: Record<string, any>;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  status: 'pending' | 'sent' | 'delivered' | 'failed' | 'cancelled';
  createdAt: Date;
  sentAt?: Date;
  deliveredAt?: Date;
  failedAt?: Date;
  error?: string;
  retryCount: number;
  maxRetries: number;
}

export interface NotificationPreferences {
  userId: string;
  channels: Record<string, boolean>;
  categories: Record<string, boolean>;
  quietHours: {
    enabled: boolean;
    start: string; // HH:MM format
    end: string;   // HH:MM format
    timezone: string;
  };
  frequency: {
    email: 'immediate' | 'daily' | 'weekly';
    sms: 'immediate' | 'daily';
    push: 'immediate';
  };
}

export interface NotificationStats {
  totalSent: number;
  totalDelivered: number;
  totalFailed: number;
  deliveryRate: number;
  failureRate: number;
  averageDeliveryTime: number;
  channelStats: Record<string, {
    sent: number;
    delivered: number;
    failed: number;
    deliveryRate: number;
  }>;
}

export class NotificationService extends EventEmitter {
  private channels: Map<string, NotificationChannel> = new Map();
  private templates: Map<string, NotificationTemplate> = new Map();
  private notifications: Map<string, Notification> = new Map();
  private preferences: Map<string, NotificationPreferences> = new Map();
  private stats: NotificationStats = {
    totalSent: 0,
    totalDelivered: 0,
    totalFailed: 0,
    deliveryRate: 0,
    failureRate: 0,
    averageDeliveryTime: 0,
    channelStats: {}
  };

  constructor() {
    super();
    this.initializeDefaultChannels();
  }

  public addChannel(channel: NotificationChannel): void {
    this.channels.set(channel.name, channel);
    this.emit('channel-added', channel);
  }

  public removeChannel(channelName: string): boolean {
    const removed = this.channels.delete(channelName);
    if (removed) {
      this.emit('channel-removed', channelName);
    }
    return removed;
  }

  public getChannel(channelName: string): NotificationChannel | undefined {
    return this.channels.get(channelName);
  }

  public listChannels(): NotificationChannel[] {
    return Array.from(this.channels.values());
  }

  public addTemplate(template: NotificationTemplate): void {
    this.templates.set(template.id, template);
    this.emit('template-added', template);
  }

  public getTemplate(templateId: string): NotificationTemplate | undefined {
    return this.templates.get(templateId);
  }

  public listTemplates(): NotificationTemplate[] {
    return Array.from(this.templates.values());
  }

  public async sendNotification(
    templateId: string,
    recipient: string,
    data: Record<string, any> = {},
    options: {
      channels?: string[];
      priority?: 'low' | 'normal' | 'high' | 'urgent';
      maxRetries?: number;
    } = {}
  ): Promise<string> {
    const template = this.templates.get(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }

    if (!template.enabled) {
      throw new Error(`Template ${templateId} is disabled`);
    }

    const notification: Notification = {
      id: randomUUID(),
      templateId,
      recipient,
      channels: options.channels || template.channels,
      data,
      priority: options.priority || 'normal',
      status: 'pending',
      createdAt: new Date(),
      retryCount: 0,
      maxRetries: options.maxRetries || 3
    };

    this.notifications.set(notification.id, notification);
    this.emit('notification-created', notification);

    // Check user preferences
    const userPrefs = this.preferences.get(recipient);
    if (userPrefs) {
      notification.channels = notification.channels.filter(channel => 
        userPrefs.channels[channel] !== false
      );
    }

    // Send notification
    await this.processNotification(notification);

    return notification.id;
  }

  public async sendBulkNotifications(
    templateId: string,
    recipients: string[],
    data: Record<string, any> = {},
    options: {
      channels?: string[];
      priority?: 'low' | 'normal' | 'high' | 'urgent';
      maxRetries?: number;
    } = {}
  ): Promise<string[]> {
    const notificationIds: string[] = [];

    for (const recipient of recipients) {
      try {
        const id = await this.sendNotification(templateId, recipient, data, options);
        notificationIds.push(id);
      } catch (error) {
        this.emit('bulk-notification-error', { recipient, error });
      }
    }

    return notificationIds;
  }

  public async cancelNotification(notificationId: string): Promise<boolean> {
    const notification = this.notifications.get(notificationId);
    if (notification && notification.status === 'pending') {
      notification.status = 'cancelled';
      this.emit('notification-cancelled', notification);
      return true;
    }
    return false;
  }

  public getNotification(notificationId: string): Notification | undefined {
    return this.notifications.get(notificationId);
  }

  public getUserNotifications(userId: string, limit: number = 50): Notification[] {
    return Array.from(this.notifications.values())
      .filter(n => n.recipient === userId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(0, limit);
  }

  public setUserPreferences(userId: string, preferences: NotificationPreferences): void {
    this.preferences.set(userId, preferences);
    this.emit('preferences-updated', { userId, preferences });
  }

  public getUserPreferences(userId: string): NotificationPreferences | undefined {
    return this.preferences.get(userId);
  }

  public getStats(): NotificationStats {
    this.calculateStats();
    return { ...this.stats };
  }

  public async retryFailedNotifications(): Promise<number> {
    let retryCount = 0;
    const failedNotifications = Array.from(this.notifications.values())
      .filter(n => n.status === 'failed' && n.retryCount < n.maxRetries);

    for (const notification of failedNotifications) {
      notification.retryCount++;
      notification.status = 'pending';
      await this.processNotification(notification);
      retryCount++;
    }

    return retryCount;
  }

  private async processNotification(notification: Notification): Promise<void> {
    try {
      const template = this.templates.get(notification.templateId);
      if (!template) {
        throw new Error('Template not found');
      }

      // Check quiet hours
      const userPrefs = this.preferences.get(notification.recipient);
      if (userPrefs?.quietHours.enabled) {
        if (this.isInQuietHours(userPrefs.quietHours)) {
          // Schedule for later
          setTimeout(() => this.processNotification(notification), this.getTimeUntilQuietHoursEnd(userPrefs.quietHours));
          return;
        }
      }

      // Send through each channel
      for (const channelName of notification.channels) {
        const channel = this.channels.get(channelName);
        if (channel && channel.enabled) {
          try {
            await this.sendThroughChannel(notification, template, channel);
          } catch (error) {
            this.emit('channel-error', { notification, channel: channelName, error });
          }
        }
      }

      notification.status = 'sent';
      notification.sentAt = new Date();
      this.stats.totalSent++;

      this.emit('notification-sent', notification);
    } catch (error) {
      notification.status = 'failed';
      notification.failedAt = new Date();
      notification.error = error instanceof Error ? error.message : 'Unknown error';
      this.stats.totalFailed++;

      this.emit('notification-failed', { notification, error });
    }
  }

  private async sendThroughChannel(
    notification: Notification,
    template: NotificationTemplate,
    channel: NotificationChannel
  ): Promise<void> {
    // Simulate sending through different channels
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));

    // Simulate occasional failures
    if (Math.random() < 0.1) { // 10% failure rate
      throw new Error(`Failed to send through ${channel.type} channel`);
    }

    // Mark as delivered
    notification.status = 'delivered';
    notification.deliveredAt = new Date();
    this.stats.totalDelivered++;

    this.emit('notification-delivered', { notification, channel: channel.name });
  }

  private isInQuietHours(quietHours: NotificationPreferences['quietHours']): boolean {
    if (!quietHours.enabled) return false;

    const now = new Date();
    const currentTime = now.toLocaleTimeString('en-US', { 
      hour12: false, 
      timeZone: quietHours.timezone 
    });

    return currentTime >= quietHours.start && currentTime <= quietHours.end;
  }

  private getTimeUntilQuietHoursEnd(quietHours: NotificationPreferences['quietHours']): number {
    const now = new Date();
    const endTime = new Date();
    const [endHour, endMinute] = quietHours.end.split(':').map(Number);
    
    endTime.setHours(endHour, endMinute, 0, 0);
    
    if (endTime <= now) {
      endTime.setDate(endTime.getDate() + 1);
    }

    return endTime.getTime() - now.getTime();
  }

  private calculateStats(): void {
    const total = this.stats.totalSent;
    if (total > 0) {
      this.stats.deliveryRate = (this.stats.totalDelivered / total) * 100;
      this.stats.failureRate = (this.stats.totalFailed / total) * 100;
    }

    // Calculate channel-specific stats
    for (const channel of this.channels.values()) {
      const channelNotifications = Array.from(this.notifications.values())
        .filter(n => n.channels.includes(channel.name));

      const sent = channelNotifications.length;
      const delivered = channelNotifications.filter(n => n.status === 'delivered').length;
      const failed = channelNotifications.filter(n => n.status === 'failed').length;

      this.stats.channelStats[channel.name] = {
        sent,
        delivered,
        failed,
        deliveryRate: sent > 0 ? (delivered / sent) * 100 : 0
      };
    }
  }

  private initializeDefaultChannels(): void {
    // Add default channels
    this.addChannel({
      name: 'email',
      type: 'email',
      enabled: true,
      config: {},
      priority: 1
    });

    this.addChannel({
      name: 'push',
      type: 'push',
      enabled: true,
      config: {},
      priority: 2
    });

    this.addChannel({
      name: 'sms',
      type: 'sms',
      enabled: false,
      config: {},
      priority: 3
    });
  }
}

export class NotificationTemplateBuilder {
  private template: Partial<NotificationTemplate> = {};

  public id(id: string): NotificationTemplateBuilder {
    this.template.id = id;
    return this;
  }

  public name(name: string): NotificationTemplateBuilder {
    this.template.name = name;
    return this;
  }

  public subject(subject: string): NotificationTemplateBuilder {
    this.template.subject = subject;
    return this;
  }

  public message(message: string): NotificationTemplateBuilder {
    this.template.message = message;
    return this;
  }

  public channels(channels: string[]): NotificationTemplateBuilder {
    this.template.channels = channels;
    return this;
  }

  public variables(variables: string[]): NotificationTemplateBuilder {
    this.template.variables = variables;
    return this;
  }

  public category(category: string): NotificationTemplateBuilder {
    this.template.category = category;
    return this;
  }

  public enabled(enabled: boolean): NotificationTemplateBuilder {
    this.template.enabled = enabled;
    return this;
  }

  public build(): NotificationTemplate {
    if (!this.template.id || !this.template.name || !this.template.message) {
      throw new Error('Template id, name, and message are required');
    }

    return {
      id: this.template.id,
      name: this.template.name,
      subject: this.template.subject,
      message: this.template.message,
      channels: this.template.channels || ['email'],
      variables: this.template.variables || [],
      category: this.template.category || 'general',
      enabled: this.template.enabled !== false
    };
  }
}
