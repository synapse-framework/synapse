import { IncomingMessage, ServerResponse } from 'node:http';
import { EventEmitter } from 'node:events';

export interface GraphQLSchema {
  types: Map<string, GraphQLType>;
  queries: Map<string, GraphQLField>;
  mutations: Map<string, GraphQLField>;
  subscriptions: Map<string, GraphQLField>;
}

export interface GraphQLType {
  name: string;
  kind: 'OBJECT' | 'SCALAR' | 'ENUM' | 'INPUT' | 'INTERFACE' | 'UNION';
  fields?: Map<string, GraphQLField>;
  description?: string;
}

export interface GraphQLField {
  name: string;
  type: string;
  description?: string;
  args?: Map<string, GraphQLArgument>;
  resolver?: GraphQLResolver;
  isDeprecated?: boolean;
  deprecationReason?: string;
}

export interface GraphQLArgument {
  name: string;
  type: string;
  defaultValue?: any;
  description?: string;
}

export interface GraphQLResolver {
  (parent: any, args: any, context: GraphQLContext, info: GraphQLInfo): any;
}

export interface GraphQLContext {
  request: IncomingMessage;
  response: ServerResponse;
  user?: any;
  dataSources?: any;
}

export interface GraphQLInfo {
  fieldName: string;
  fieldNodes: any[];
  returnType: any;
  parentType: any;
  path: any;
  schema: any;
  fragments: any;
  rootValue: any;
  operation: any;
  variableValues: any;
}

export interface GraphQLRequest {
  query: string;
  variables?: Record<string, any>;
  operationName?: string;
}

export interface GraphQLResponse {
  data?: any;
  errors?: GraphQLError[];
  extensions?: Record<string, any>;
}

export interface GraphQLError {
  message: string;
  locations?: Array<{ line: number; column: number }>;
  path?: Array<string | number>;
  extensions?: Record<string, any>;
}

export interface GraphQLOptions {
  schema?: GraphQLSchema;
  rootValue?: any;
  context?: (req: IncomingMessage, res: ServerResponse) => GraphQLContext;
  formatError?: (error: GraphQLError) => GraphQLError;
  introspection?: boolean;
  playground?: boolean;
  debug?: boolean;
}

export class GraphQLServer extends EventEmitter {
  private schema: GraphQLSchema;
  private options: Required<GraphQLOptions>;

  constructor(options: GraphQLOptions = {}) {
    super();
    
    this.schema = options.schema || this.createDefaultSchema();
    this.options = {
      rootValue: {},
      context: (req, res) => ({ request: req, response: res }),
      formatError: (error) => error,
      introspection: true,
      playground: true,
      debug: false,
      ...options
    };
  }

  public async execute(request: GraphQLRequest, context: GraphQLContext): Promise<GraphQLResponse> {
    try {
      // Parse the query
      const parsedQuery = this.parseQuery(request.query);
      if (parsedQuery.errors) {
        return { errors: parsedQuery.errors };
      }

      // Validate the query
      const validationErrors = this.validateQuery(parsedQuery.query, this.schema);
      if (validationErrors.length > 0) {
        return { errors: validationErrors };
      }

      // Execute the query
      const result = await this.executeQuery(parsedQuery.query, request.variables || {}, context);

      return { data: result };
    } catch (error) {
      const graphqlError: GraphQLError = {
        message: error instanceof Error ? error.message : 'Unknown error',
        extensions: {
          code: 'INTERNAL_ERROR'
        }
      };

      return { errors: [graphqlError] };
    }
  }

  public createHandler() {
    return async (req: IncomingMessage, res: ServerResponse) => {
      if (req.method === 'GET' && this.options.playground) {
        return this.servePlayground(req, res);
      }

      if (req.method !== 'POST') {
        res.writeHead(405, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Method not allowed' }));
        return;
      }

      try {
        let body = '';
        req.on('data', chunk => {
          body += chunk.toString();
        });

        req.on('end', async () => {
          try {
            const request: GraphQLRequest = JSON.parse(body);
            const context = this.options.context(req, res);
            const response = await this.execute(request, context);

            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(response));
          } catch (error) {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Invalid request body' }));
          }
        });
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Internal server error' }));
      }
    };
  }

  private parseQuery(query: string): { query?: any; errors?: GraphQLError[] } {
    try {
      // Simple query parser - in a real implementation, you would use a proper GraphQL parser
      const tokens = this.tokenize(query);
      const ast = this.parseAST(tokens);
      return { query: ast };
    } catch (error) {
      return {
        errors: [{
          message: `Syntax error: ${error instanceof Error ? error.message : 'Unknown error'}`,
          locations: [{ line: 1, column: 1 }]
        }]
      };
    }
  }

  private tokenize(query: string): string[] {
    const tokens: string[] = [];
    let current = '';
    let inString = false;
    let stringChar = '';

    for (let i = 0; i < query.length; i++) {
      const char = query[i];
      
      if (inString) {
        if (char === stringChar) {
          inString = false;
          tokens.push(current + char);
          current = '';
        } else {
          current += char;
        }
      } else if (char === '"' || char === "'") {
        inString = true;
        stringChar = char;
        current += char;
      } else if (char === ' ' || char === '\n' || char === '\t') {
        if (current.trim()) {
          tokens.push(current.trim());
          current = '';
        }
      } else if (char === '{' || char === '}' || char === '(' || char === ')' || char === ':' || char === ',') {
        if (current.trim()) {
          tokens.push(current.trim());
          current = '';
        }
        tokens.push(char);
      } else {
        current += char;
      }
    }

    if (current.trim()) {
      tokens.push(current.trim());
    }

    return tokens;
  }

  private parseAST(tokens: string[]): any {
    // Simple AST parser - in a real implementation, you would use a proper GraphQL parser
    let index = 0;

    const parseOperation = (): any => {
      if (tokens[index] === 'query' || tokens[index] === 'mutation' || tokens[index] === 'subscription') {
        const operation = tokens[index++];
        const name = tokens[index] && tokens[index] !== '{' ? tokens[index++] : null;
        
        if (tokens[index] === '(') {
          // Parse arguments
          index++; // Skip '('
          const args: any[] = [];
          while (tokens[index] !== ')') {
            if (tokens[index] === ',') {
              index++;
              continue;
            }
            args.push(tokens[index++]);
          }
          index++; // Skip ')'
        }

        if (tokens[index] === '{') {
          index++; // Skip '{'
          const fields = this.parseFields();
          return { operation, name, fields };
        }
      }
      return null;
    };

    const parseFields = (): any[] => {
      const fields: any[] = [];
      
      while (tokens[index] !== '}') {
        if (tokens[index] === ',') {
          index++;
          continue;
        }
        
        const fieldName = tokens[index++];
        let alias: string | undefined;
        
        if (tokens[index] === ':') {
          alias = fieldName;
          index++; // Skip ':'
          const actualName = tokens[index++];
        }

        let args: any = {};
        if (tokens[index] === '(') {
          index++; // Skip '('
          args = this.parseArguments();
        }

        let subFields: any[] = [];
        if (tokens[index] === '{') {
          index++; // Skip '{'
          subFields = this.parseFields();
        }

        fields.push({
          name: fieldName,
          alias,
          args,
          fields: subFields
        });
      }
      
      index++; // Skip '}'
      return fields;
    };

    const parseArguments = (): any => {
      const args: any = {};
      
      while (tokens[index] !== ')') {
        if (tokens[index] === ',') {
          index++;
          continue;
        }
        
        const argName = tokens[index++];
        if (tokens[index] === ':') {
          index++; // Skip ':'
          const argValue = tokens[index++];
          args[argName] = argValue;
        }
      }
      
      index++; // Skip ')'
      return args;
    };

    return parseOperation();
  }

  private validateQuery(query: any, schema: GraphQLSchema): GraphQLError[] {
    const errors: GraphQLError[] = [];
    
    // Simple validation - in a real implementation, you would use a proper GraphQL validator
    if (!query || !query.fields) {
      errors.push({
        message: 'Invalid query structure',
        locations: [{ line: 1, column: 1 }]
      });
    }

    return errors;
  }

  private async executeQuery(query: any, variables: Record<string, any>, context: GraphQLContext): Promise<any> {
    const result: any = {};

    for (const field of query.fields) {
      const resolver = this.getResolver(field.name);
      if (resolver) {
        try {
          result[field.alias || field.name] = await resolver(
            this.options.rootValue,
            { ...field.args, ...variables },
            context,
            {} as GraphQLInfo
          );
        } catch (error) {
          throw new Error(`Error resolving field ${field.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      } else {
        result[field.alias || field.name] = null;
      }
    }

    return result;
  }

  private getResolver(fieldName: string): GraphQLResolver | undefined {
    // Check queries first
    const queryField = this.schema.queries.get(fieldName);
    if (queryField?.resolver) {
      return queryField.resolver;
    }

    // Check mutations
    const mutationField = this.schema.mutations.get(fieldName);
    if (mutationField?.resolver) {
      return mutationField.resolver;
    }

    // Check subscriptions
    const subscriptionField = this.schema.subscriptions.get(fieldName);
    if (subscriptionField?.resolver) {
      return subscriptionField.resolver;
    }

    return undefined;
  }

  private servePlayground(req: IncomingMessage, res: ServerResponse): void {
    const html = `
<!DOCTYPE html>
<html>
<head>
  <title>GraphQL Playground</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
    .header { background: #2c3e50; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .playground { background: #f8f9fa; padding: 20px; border-radius: 8px; border: 1px solid #dee2e6; }
    .query-editor { width: 100%; height: 300px; font-family: 'Monaco', 'Menlo', monospace; }
    .execute-btn { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 10px 0; }
    .result { background: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 10px; font-family: 'Monaco', 'Menlo', monospace; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ðŸš€ GraphQL Playground</h1>
      <p>Test your GraphQL queries and mutations</p>
    </div>
    
    <div class="playground">
      <h3>Query Editor</h3>
      <textarea class="query-editor" id="query" placeholder="Enter your GraphQL query here...">
query {
  hello
  users {
    id
    name
    email
  }
}
      </textarea>
      
      <button class="execute-btn" onclick="executeQuery()">Execute Query</button>
      
      <div id="result" class="result" style="display: none;"></div>
    </div>
  </div>

  <script>
    async function executeQuery() {
      const query = document.getElementById('query').value;
      const resultDiv = document.getElementById('result');
      
      try {
        const response = await fetch('/graphql', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ query })
        });
        
        const result = await response.json();
        resultDiv.textContent = JSON.stringify(result, null, 2);
        resultDiv.style.display = 'block';
      } catch (error) {
        resultDiv.textContent = 'Error: ' + error.message;
        resultDiv.style.display = 'block';
      }
    }
  </script>
</body>
</html>
    `;

    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(html);
  }

  private createDefaultSchema(): GraphQLSchema {
    const schema: GraphQLSchema = {
      types: new Map(),
      queries: new Map(),
      mutations: new Map(),
      subscriptions: new Map()
    };

    // Add basic types
    schema.types.set('String', {
      name: 'String',
      kind: 'SCALAR',
      description: 'A string scalar type'
    });

    schema.types.set('Int', {
      name: 'Int',
      kind: 'SCALAR',
      description: 'An integer scalar type'
    });

    schema.types.set('Boolean', {
      name: 'Boolean',
      kind: 'SCALAR',
      description: 'A boolean scalar type'
    });

    // Add basic queries
    schema.queries.set('hello', {
      name: 'hello',
      type: 'String',
      description: 'A simple hello world query',
      resolver: () => 'Hello, GraphQL!'
    });

    return schema;
  }

  public addType(type: GraphQLType): void {
    this.schema.types.set(type.name, type);
  }

  public addQuery(field: GraphQLField): void {
    this.schema.queries.set(field.name, field);
  }

  public addMutation(field: GraphQLField): void {
    this.schema.mutations.set(field.name, field);
  }

  public addSubscription(field: GraphQLField): void {
    this.schema.subscriptions.set(field.name, field);
  }

  public getSchema(): GraphQLSchema {
    return this.schema;
  }
}
