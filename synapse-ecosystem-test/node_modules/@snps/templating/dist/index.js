import { readFile } from 'node:fs/promises';
import { join } from 'node:path';
export class TemplateEngine {
    templateCache = new Map();
    cacheEnabled = true;
    constructor() {
        console.log('TemplateEngine created');
    }
    async render(template, data = {}) {
        return this.processTemplate(template, data);
    }
    async renderFile(filename, data = {}) {
        try {
            let template;
            if (this.cacheEnabled && this.templateCache.has(filename)) {
                template = this.templateCache.get(filename);
            }
            else {
                template = await readFile(filename, 'utf-8');
                if (this.cacheEnabled) {
                    this.templateCache.set(filename, template);
                }
            }
            return this.processTemplate(template, data);
        }
        catch (error) {
            throw new Error(`Template file '${filename}' not found`);
        }
    }
    processTemplate(template, data) {
        let result = template;
        // Handle unescaped variables with {{{variable}}} syntax first
        result = result.replace(/\{\{\{([^}]+)\}\}\}/g, (match, key) => {
            const value = this.getNestedValue(data, key.trim());
            return String(value || '');
        });
        // Handle conditional blocks {{#if condition}}...{{/if}}
        result = result.replace(/\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, condition, content) => {
            const value = this.getNestedValue(data, condition.trim());
            return this.isTruthy(value) ? content : '';
        });
        // Handle loops {{#each array}}...{{/each}}
        result = result.replace(/\{\{#each\s+([^}]+)\}\}([\s\S]*?)\{\{\/each\}\}/g, (match, arrayKey, content) => {
            const array = this.getNestedValue(data, arrayKey.trim());
            if (!Array.isArray(array))
                return '';
            return array.map(item => {
                return content.replace(/\{\{this\}\}/g, this.escapeHtml(String(item)));
            }).join('');
        });
        // Handle variables with {{variable}} syntax last
        result = result.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
            const value = this.getNestedValue(data, key.trim());
            return this.escapeHtml(String(value || ''));
        });
        return result;
    }
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => {
            return current && current[key] !== undefined ? current[key] : undefined;
        }, obj);
    }
    isTruthy(value) {
        if (typeof value === 'boolean')
            return value;
        if (typeof value === 'string')
            return value.length > 0;
        if (typeof value === 'number')
            return value !== 0;
        if (Array.isArray(value))
            return value.length > 0;
        if (value === null || value === undefined)
            return false;
        return true;
    }
    escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        return text.replace(/[&<>"']/g, (char) => map[char] || char);
    }
    clearCache() {
        this.templateCache.clear();
    }
    setCacheEnabled(enabled) {
        this.cacheEnabled = enabled;
    }
}
//# sourceMappingURL=index.js.map