import { readFile } from 'node:fs/promises';
import { join } from 'node:path';

export class TemplateEngine {
  private templateCache: Map<string, string> = new Map();
  private cacheEnabled: boolean = true;

  constructor() {
    console.log('TemplateEngine created');
  }

  public async render(template: string, data: Record<string, any> = {}): Promise<string> {
    return this.processTemplate(template, data);
  }

  public async renderFile(filename: string, data: Record<string, any> = {}): Promise<string> {
    try {
      let template: string;
      
      if (this.cacheEnabled && this.templateCache.has(filename)) {
        template = this.templateCache.get(filename)!;
      } else {
        template = await readFile(filename, 'utf-8');
        if (this.cacheEnabled) {
          this.templateCache.set(filename, template);
        }
      }
      
      return this.processTemplate(template, data);
    } catch (error) {
      throw new Error(`Template file '${filename}' not found`);
    }
  }

  private processTemplate(template: string, data: Record<string, any>): string {
    let result = template;

    // Handle unescaped variables with {{{variable}}} syntax first
    result = result.replace(/\{\{\{([^}]+)\}\}\}/g, (match, key) => {
      const value = this.getNestedValue(data, key.trim());
      return String(value || '');
    });

    // Handle conditional blocks {{#if condition}}...{{/if}}
    result = result.replace(/\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, condition, content) => {
      const value = this.getNestedValue(data, condition.trim());
      return this.isTruthy(value) ? content : '';
    });

    // Handle loops {{#each array}}...{{/each}}
    result = result.replace(/\{\{#each\s+([^}]+)\}\}([\s\S]*?)\{\{\/each\}\}/g, (match, arrayKey, content) => {
      const array = this.getNestedValue(data, arrayKey.trim());
      if (!Array.isArray(array)) return '';
      
      return array.map(item => {
        return content.replace(/\{\{this\}\}/g, this.escapeHtml(String(item)));
      }).join('');
    });

    // Handle variables with {{variable}} syntax last
    result = result.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
      const value = this.getNestedValue(data, key.trim());
      return this.escapeHtml(String(value || ''));
    });

    return result;
  }

  private getNestedValue(obj: Record<string, any>, path: string): any {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }

  private isTruthy(value: any): boolean {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'string') return value.length > 0;
    if (typeof value === 'number') return value !== 0;
    if (Array.isArray(value)) return value.length > 0;
    if (value === null || value === undefined) return false;
    return true;
  }

  private escapeHtml(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    
    return text.replace(/[&<>"']/g, (char) => map[char] || char);
  }

  public clearCache(): void {
    this.templateCache.clear();
  }

  public setCacheEnabled(enabled: boolean): void {
    this.cacheEnabled = enabled;
  }
}
